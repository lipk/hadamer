#include <refplan.h>
#include <util.h>

typedef struct Node Node;

static int getSingleDifferingBit(uint32_t a, uint32_t b)
{
	uint32_t c = a ^ b;
	if (c == 0) {
		return -1;
	}
	int result = 0;
	while (c % 2 == 0) {
		c >>= 1;
		result++;
	}
	if (c == 1) {
		return result;
	} else {
		return -1;
	}
}

RefinePlan *RefinePlan_mergeIfPossible(RefinePlan *plan1, uint32_t index1,
									   RefinePlan *plan2, uint32_t index2,
									   uint32_t currentLevel)
{
    if (plan1->level != plan2->level) {
        return NULL;
    }

    RefinePlan *merged = MALLOC(RefinePlan);
	merged->level = plan1->level;
    merged->propagate = true;
    uint64_t offset1 = 1 << (plan1->level - currentLevel - 1);
    uint64_t offset2 = 1 << (plan2->level - currentLevel - 1);
    int diffBit = -1;
    int mismatch = 0;
    for (int i = 0; i<DIM; ++i) {
        uint64_t posoff1 = index1 & (1 << i) ? offset1 : 0;
        uint64_t posoff2 = index2 & (1 << i) ? offset2 : 0;
        if ((index1 ^ index2) & (1 << i)) {
            if (diffBit != -1) {
                free(merged);
                return NULL;
            } else {
                diffBit = i;
            }
        }
        if (plan1->pos[i] + posoff1 == plan2->pos[i] + posoff2
            && plan1->size[i] == plan2->size[i]) {
            merged->pos[i] = plan1->pos[i] + posoff1;
            merged->size[i] = plan1->size[i];
        } else if (mismatch > 0) {
            free(merged);
            return NULL;
        } else if (plan1->pos[i] + posoff1 + plan1->size[i] == plan2->pos[i] + posoff2) {
            merged->pos[i] = plan1->pos[i] + posoff1;
            merged->size[i] = plan1->size[i] + plan2->size[i];
            mismatch++;
        } else if (plan2->pos[i] + posoff2 + plan2->size[i] == plan1->pos[i] + posoff1) {
            merged->pos[i] = plan2->pos[i] + posoff2;
            merged->size[i] = plan1->size[i] + plan2->size[i];
            mismatch++;
        } else {
            free(merged);
            return NULL;
        }
	}
	Buffer *nodesBuf = Buffer_create(sizeof(Node*), sizeof(Node*), merged->size);
	uint64_t pos1[DIM], pos2[DIM], pos3[DIM];
	for (int i = 0; i<DIM; ++i) {
		pos1[i] = 0;
		pos2[i] = 0;
		pos3[i] = 0;
		if (i == diffBit) {
			if (index1 & (1 << i)) {
				pos1[i] = merged->size[i];
			} else {
				pos2[i] = merged->size[i];
			}
		}
	}
	Array *array1 = Array_create(nodesBuf, plan1->size, pos1);
    Array *array2 = Array_create(nodesBuf, plan2->size, pos2);
    @
    function copyNodes(src, dst)
        for i=0,args.dim-1 do
            emiti('for (uint64_t x'..i..'=0;x'..i..'<'..dst..'->size['..i..'];++x'..i..'){\n')
            ind()
        end
        emiti('*GET(Node*,'..dst)
        for i=0,args.dim-1 do
            emit(',x'..i)
        end
        emit(') = *GET(Node*,'..src)
        for i=0,args.dim-1 do
            emit(',x'..i)
        end
        emit(');\n');
        for i=0,args.dim-1 do
            unind()
            emiti('}\n')
        end
    end
    copyNodes('plan1->nodes', 'array1')
    copyNodes('plan2->nodes', 'array2')
	@
	Array *final = Array_create(nodesBuf, merged->size, pos3);
	merged->nodes = final;
	DESTROY(Array, array1);
	DESTROY(Array, array2);
    return merged;
}

void RefinePlan_destroy(RefinePlan *plan)
{
	DESTROY(Array, plan->nodes);
	free(plan);
}
