#include <tree.h>
#include <functions.h>
#include <stdio.h>
#include <util.h>

/* todo: remove */
const uint64_t pos0[DIM] = {@for i=1,args.dim do emit('0,') end@};

@
function upname(base)
	return 'upsamplerFunction_' .. base
end
function downname(base)
	return 'downsamplerFunction_' .. base
end

function genUpsampler(name, datatype)
	emit('static void ' .. upname(name) .. '(Array *x, Array *y[TREECH])\n{\n')
    ind()
	for i=1,args.dim do
		j = args.dim-i+1
        emiti('for (int a'..j..' = 0; a'..j..' < 2; ++a'..j..') {\n')
        ind()
	end
	for i=1,args.dim do
		j = args.dim-i+1
        emiti('for (int b'..j..' = 0; b'..j..' < BLOCKSIZE/2; ++b'..j..') {\n')
        ind()
	end
    emiti('Array *arr = y[a1')
	for i=2,args.dim do
		emit(' | (a'..i..' << '..(i-1)..')')
	end
	emit('];\n')
    emiti(name..'(GET('..datatype..', x');
	for i=1,args.dim do
		emit(', b'..i..'+BLOCKSIZE/2*a'..i)
	end
	emit(')');
    ind()
	for i=0,math.floor(2^args.dim)-1 do
        emit(',\n')
        emiti('GET('..datatype..', arr');
		for j=1,args.dim do
			add = ''
			if i & (1 << (j-1)) ~= 0 then
				add = '+1'
			end
			emit(', 2*b'..j..add)
		end
		emit(')')
	end
	emit(');\n')
    unind()
	for i=1,args.dim*2+1 do
        unind()
        emiti('}\n')
	end
end

function genDownsampler(name, datatype)
	emit('static void ' .. downname(name) .. '(Array *x[TREECH], Array *y)\n{\n')
    ind()
	for i=1,args.dim do
		j = args.dim-i+1
        emiti('for (int a'..j..' = 0; a'..j..' < 2; ++a'..j..') {\n')
        ind()
	end
	for i=1,args.dim do
		j = args.dim-i+1
        emiti('for (int b'..j..' = 0; b'..j..' < BLOCKSIZE/2; ++b'..j..') {\n')
        ind()
	end
    emiti('Array *arr = x[a1')
	for i=2,args.dim do
		emit(' | (a'..i..' << '..(i-1)..')')
	end
	emit('];\n')
    emiti(name..'(')
    ind()
	for i=0,math.floor(2^args.dim)-1 do
		emit('GET('..datatype..', arr')
		for j=1,args.dim do
			add = ''
			if i & (1 << (j-1)) ~= 0 then
				add = '+1'
			end
			emit(', 2*b'..j..add)
		end
        emit('),\n')
        emiti('')
	end
	emit('GET('..datatype..', y')
	for i=1,args.dim do
		emit(', b'..i..'+BLOCKSIZE/2*a'..i)
	end
	emit('));\n')
    unind()
	for i=1,args.dim*2+1 do
        unind()
        emiti('}\n')
	end
end

ups = {}
downs = {}

for _,grid in pairs(args.grids) do
	if ups[grid.upsample] == nil then
		genUpsampler(grid.upsample, grid.datatype)
		ups[grid.upsample] = true
	end
	if (downs[grid.downsample]) == nil then
		genDownsampler(grid.downsample, grid.datatype)
		downs[grid.downsample] = true
	end
end
@

static inline bool Node_isLeaf(Node *node)
{
    return node->children[0] == NULL;
}

static Node* Tree_createLeaf(Tree *tree, Node *parent, Buffer *buffers[GRIDNUM], const uint64_t pos[DIM])
{
	Node *leaf = MALLOC(Node);
	leaf->parent = parent;
	if (parent == NULL) {
		leaf->level = 0;
	} else {
		leaf->level = parent->level+1;
	}
	leaf->action = NOTHING;
    for (int i = 0; i<GRIDNUM; ++i) {
        leaf->data[i] = Array_create(buffers[i], tree->blocksize, pos);
	}
	for (int j = 0; j<TREECH; ++j) {
		leaf->children[j] = NULL;
	}
	return leaf;
}

static void Node_destroy(Node* node) {
	assert(Node_isLeaf(node));
	for (int i = 0; i<GRIDNUM; ++i) {
		DESTROY(Array, node->data[i]);
	}
	free(node);
}

static void Tree_splitNode(Tree *tree, Node* node, Buffer *buffers[GRIDNUM], uint64_t pos[DIM]) {
	assert(Node_isLeaf(node));
	for (int i = 0; i<TREECH; ++i) {
        uint64_t leafPos[DIM];
        for (int j = 0; j<DIM; ++j) {
            leafPos[j] = pos[j] + (i & (1 << j) ? BLOCKSIZE : 0);
        }
        node->children[i] = Tree_createLeaf(tree, node, buffers, leafPos);
	}
	for (int i = 0; i<GRIDNUM; ++i) {
		Array *newdata[TREECH];
		for (int j = 0; j<TREECH; ++j) {
			newdata[j] = node->children[j]->data[i];
		}
		tree->gridinfo[i].upsample(node->data[i], newdata);
	}
}

static void Tree_mergeNode(Tree *tree, Node* node) {
	assert(!Node_isLeaf(node));
	for (int i = 0; i<GRIDNUM; ++i) {
		assert(Node_isLeaf(node->children[i]));
		Array *olddata[TREECH];
		for (int j = 0; j<TREECH; ++j) {
			olddata[j] = node->children[j]->data[i];
        }
		tree->gridinfo[i].downsample(olddata, node->data[i]);
		for (int j = 0; j<TREECH; ++j) {
			DESTROY(Node, node->children[j]);
		}
	}
}

static Buffer** createBuffers(uint64_t size[DIM])
{
    Buffer **buffers = MALLOCN(Buffer*, GRIDNUM);
    for (int i = 0; i<GRIDNUM; ++i) {
        buffers[i] = Buffer_create(sizeof(Node), sizeof(Node), size);
    }
    return buffers;
}

Tree *Tree_create()
{
	Tree *tree = MALLOC(Tree);
	for (int i = 0; i<DIM; ++i) {
		tree->blocksize[i] = BLOCKSIZE;
	}

	@
	i = 0
	for _,grid in pairs(args.grids) do
		emit('tree->gridinfo[' .. i .. '].itemsize = sizeof(' .. grid.datatype .. ');\n')
		emit('tree->gridinfo[' .. i .. '].alignment = sizeof(' .. grid.datatype .. ');\n')
		emit('tree->gridinfo[' .. i .. '].upsample = &' .. upname(grid.upsample) .. ';\n')
		emit('tree->gridinfo[' .. i .. '].downsample = &' .. downname(grid.downsample) .. ';\n')
	end
	@
    Buffer **buffers = createBuffers(tree->blocksize);
    tree->root = Tree_createLeaf(tree, NULL, buffers, pos0);
    free(buffers);
    return tree;
}

static void Node_calculateRefinePlan(Node *node)
{
    if (Node_isLeaf(node)) {
        if (!(node->action & REFINE)) {
            return;
        }
        RefinePlan *plan = MALLOC(RefinePlan);
        plan->level = node->level;
        for (int i = 0; i<DIM; ++i) {
            plan->pos[i] = 0;
            plan->size[i] = 1;
        }
        plan->nodes = Array_createWithBuffer(sizeof(Node*), sizeof(Node*), plan->size);
        *GETA(Node*, plan->nodes, plan->pos) = node;
        plan->propagate = true;
        Vector_push(&node->refplan, plan);
    } else {
        bool changed = false;
        for (uint32_t i = 0; i<TREECH; ++i) {
            for (uint32_t j = 0; j<node->children[i]->refplan.size;) {
                RefinePlan* plan = (RefinePlan*) node->children[i]->refplan.data[j];
                if (plan->propagate) {
                    Vector_push(&node->refplan, plan);
                    RefinePlan_propagate(plan, i, node->level);
                    Vector_swapErase(&node->children[i]->refplan, j);
                } else {
                    j++;
                }
            }
        }
        do {
            for (uint32_t pi = 0; pi<node->refplan.size; ++pi) {
                RefinePlan *plan1 = (RefinePlan*) node->refplan.data[pi];
                if (!plan1->propagate) {
                    continue;
                }
                for (uint32_t pj = 0; pj<node->refplan.size; ++pj) {
                    RefinePlan *plan2 = (RefinePlan*) node->refplan.data[pj];
                    if (!plan2->propagate) {
                        continue;
                    }
                    RefinePlan *merged = RefinePlan_mergeIfPossible(
                        plan1, plan2, node->level);
                    if (merged != NULL) {
                        DESTROY(RefinePlan, node->refplan.data[pi]);
                        DESTROY(RefinePlan, node->refplan.data[pj]);
                        Vector_swapErase(&node->refplan, pi);
                        if (pj == node->refplan.size - 2) {
                            pj = pi;
                        }
                        Vector_swapErase(&node->refplan, pj);
                        Vector_push(&node->refplan, merged);
                        changed = true;
                        if (pi == node->refplan.size) {
                            break;
                        }
                    }
                }
            }
        } while (changed);
    }
}

static void Tree_executeRefinePlan(Tree *tree, RefinePlan *plan)
{
    uint64_t size[DIM];
    for (int j = 0; j<DIM; ++j) {
        size[j] = plan->size[j] * BLOCKSIZE * 2;
    }
    Buffer **buffers = createBuffers(size);
    uint64_t index[DIM];
    uint64_t pos[DIM];
    @
    for i=0,args.dim-1 do
        local it = 'index['..i..']'
        local pos = 'pos['..i..']';
        emiti('for ('..it..' = 0, '..pos..' = 0; '..it..' < plan->nodes->size['..i..']; ++'..it..', '..pos..'+=BLOCKSIZE*2) {\n')
        ind()
    end
    emiti('Tree_splitNode(tree, *GET(Node*, plan->nodes')
    for i=0,args.dim-1 do
        emit(', index['..i..']')
    end
    emit('), buffers, pos);\n')
    for i=1,args.dim do
        unind()
        emiti('}\n')
    end
    @
}

static void Node_recursiveCalculateRefinePlan(Node *node) {
    if (!Node_isLeaf(node)) {
        for (uint32_t i = 0; i<TREECH; ++i) {
            Node_recursiveCalculateRefinePlan(node->children[i]);
        }
    }
    Node_calculateRefinePlan(node);
}

static void Tree_recursiveRestructure(Tree *tree, Node *node)
{
    if (!Node_isLeaf(node)) {
        int action = DEREFINE;
        for (uint32_t i = 0; i<TREECH; ++i) {
            action &= node->children[i]->action;
        }
        if (action & DEREFINE) {
            Tree_mergeNode(tree, node);
            return;
        }
        for (uint32_t i = 0; i<TREECH; ++i) {
            Tree_recursiveRestructure(tree, node->children[i]);
        }
    }
    for (uint64_t i = 0; i<node->refplan.size; ++i) {
        Tree_executeRefinePlan(tree, (RefinePlan*) node->refplan.data[i]);
        DESTROY(RefinePlan, node->refplan.data[i]);
    }
    node->action = NOTHING;
    Vector_clear(&node->refplan);
}

void Tree_restructure(Tree *tree)
{
    Node_recursiveCalculateRefinePlan(tree->root);
    Tree_recursiveRestructure(tree, tree->root);
}
